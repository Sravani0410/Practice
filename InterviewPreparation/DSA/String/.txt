https://chat.openai.com/share/ab4a019a-e1f3-4723-98b9-2c9f40945d05

Certainly! String-related questions are common in interviews, and they often test your understanding of string manipulation, algorithms, and problem-solving skills. Here are a few examples with solutions in JavaScript, including time and space complexity analysis. I'll provide both a brute force solution and a more optimized solution for each problem.

Problem 1: Reverse a String
        Brute Force Solution:
        function reverseString(str) {
        return str.split('').reverse().join('');
        }
        Optimized Solution:
        function reverseString(str) {
        let reversed = '';
        for (let i = str.length - 1; i >= 0; i--) {
            reversed += str[i];
        }
        return reversed;
        }
        Time Complexity: Both solutions have a time complexity of O(n), where n is the length of the string.
        Space Complexity: The brute force solution has a space complexity of O(n) due to the additional array created by split and join. 
        The optimized solution has a space complexity of O(1).

Problem 2: Anagram Check
        Brute Force Solution:
        function areAnagrams(str1, str2) {
        return str1.split('').sort().join('') === str2.split('').sort().join('');
        }
        Optimized Solution:
        function areAnagrams(str1, str2) {
        if (str1.length !== str2.length) {
            return false;
        }

        const charCount = {};

        for (let char of str1) {
            charCount[char] = (charCount[char] || 0) + 1;
        }

        for (let char of str2) {
            if (!charCount[char]) {
            return false;
            }
            charCount[char]--;
        }

        return true;
        }
        Time Complexity: The brute force solution has a time complexity of O(n log n) due to the sorting operations. 
        The optimized solution has a time complexity of O(n), where n is the length of the strings.
        Space Complexity: The brute force solution has a space complexity of O(n) due to the additional array created by split and join. 
        The optimized solution has a space complexity of O(1) as the character count object size remains constant.

Problem 3: Longest Substring Without Repeating Characters
        Brute Force Solution:
        function lengthOfLongestSubstring(s) {
        let longest = 0;
        for (let i = 0; i < s.length; i++) {
            let current = '';
            for (let j = i; j < s.length; j++) {
            if (current.includes(s[j])) {
                break;
            }
            current += s[j];
            }
            longest = Math.max(longest, current.length);
        }
        return longest;
        }
        Optimized Solution:
        function lengthOfLongestSubstring(s) {
        let longest = 0;
        let start = 0;
        const charIndex = {};

        for (let i = 0; i < s.length; i++) {
            if (charIndex[s[i]] !== undefined && charIndex[s[i]] >= start) {
            start = charIndex[s[i]] + 1;
            }
            charIndex[s[i]] = i;
            longest = Math.max(longest, i - start + 1);
        }

        return longest;
        }
        Time Complexity: The brute force solution has a time complexity of O(n^2), where n is the length of the string. 
        The optimized solution has a time complexity of O(n).
        Space Complexity: The brute force solution has a space complexity of O(n) due to the additional substring storage. 
        The optimized solution has a space complexity of O(min(n, m)), where m is the size of the character set. In this case,
        the character set is assumed to be constant, so it's O(1).

Problem 4: String to Integer (atoi)
        Problem Statement: Implement the myAtoi function, which converts a string to an integer. The function should trim leading whitespaces, handle signs (+/-), and stop converting when a non-digit character is encountered.

        Brute Force Solution:
        function myAtoi(str) {
        const num = parseInt(str.trim());
        if (isNaN(num)) return 0;
        
        const INT_MAX = Math.pow(2, 31) - 1;
        const INT_MIN = -Math.pow(2, 31);
        
        if (num > INT_MAX) return INT_MAX;
        if (num < INT_MIN) return INT_MIN;
        
        return num;
        }
        Optimized Solution:
        function myAtoi(str) {
        let i = 0;
        let sign = 1;
        let result = 0;
        const INT_MAX = Math.pow(2, 31) - 1;
        const INT_MIN = -Math.pow(2, 31);

        // Skip whitespaces
        while (str[i] === ' ') {
            i++;
        }

        // Handle sign
        if (str[i] === '-' || str[i] === '+') {
            sign = (str[i++] === '-') ? -1 : 1;
        }

        // Convert digits
        while (i < str.length && str[i] >= '0' && str[i] <= '9') {
            result = result * 10 + (str[i++] - '0');

            // Check for overflow
            if (result * sign > INT_MAX) return INT_MAX;
            if (result * sign < INT_MIN) return INT_MIN;
        }

        return result * sign;
        }
        Time Complexity: Both solutions have a time complexity of O(n), where n is the length of the input string.
        Space Complexity: Both solutions have a space complexity of O(1).

Problem 5: Implement strStr()
        Problem Statement: Implement strStr() that locates a substring within a string. Return the index of the first occurrence of the substring, or -1 if the substring is not found.

        Brute Force Solution:
        function strStr(haystack, needle) {
        if (needle === '') return 0;

        for (let i = 0; i <= haystack.length - needle.length; i++) {
            let j;
            for (j = 0; j < needle.length; j++) {
            if (haystack[i + j] !== needle[j]) {
                break;
            }
            }
            if (j === needle.length) {
            return i;
            }
        }

        return -1;
        }
        Optimized Solution:
        function strStr(haystack, needle) {
        if (needle === '') return 0;

        for (let i = 0; i <= haystack.length - needle.length; i++) {
            if (haystack.substring(i, i + needle.length) === needle) {
            return i;
            }
        }

        return -1;
        }
        Time Complexity: The brute force solution has a time complexity of O((n-m+1)m), where n is the length of the haystack and m is the length of the needle.
        The optimized solution also has a time complexity of O((n-m+1)m), but it may have a slightly better constant factor due to built-in substring comparison.

        Space Complexity: Both solutions have a space complexity of O(1).

Problem 6: Valid Palindrome
        Problem Statement: Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

        Brute Force Solution:
        function isPalindrome(str) {
        const cleanStr = str.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
        const reversedStr = cleanStr.split('').reverse().join('');
        return cleanStr === reversedStr;
        }
        Optimized Solution:
        function isPalindrome(str) {
        let left = 0;
        let right = str.length - 1;

        while (left < right) {
            while (!isAlphanumeric(str[left]) && left < right) {
            left++;
            }
            while (!isAlphanumeric(str[right]) && left < right) {
            right--;
            }

            if (str[left].toLowerCase() !== str[right].toLowerCase()) {
            return false;
            }

            left++;
            right--;
        }

        return true;
        }

        function isAlphanumeric(char) {
        return /[a-zA-Z0-9]/.test(char);
        }
        Time Complexity: The brute force solution has a time complexity of O(n), where n is the length of the input string. 
        The optimized solution also has a time complexity of O(n).

        Space Complexity: The brute force solution has a space complexity of O(n) due to the additional array created by split and join.
        The optimized solution has a space complexity of O(1).

Problem 7: Longest Common Prefix
        Problem Statement: Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string ''.

        Brute Force Solution:
        function longestCommonPrefix(strs) {
        if (!strs.length) return '';

        let prefix = strs[0];

        for (let i = 1; i < strs.length; i++) {
            let j = 0;
            while (j < prefix.length && j < strs[i].length && prefix[j] === strs[i][j]) {
            j++;
            }
            prefix = prefix.substring(0, j);
        }

        return prefix;
        }
        Optimized Solution:
        function longestCommonPrefix(strs) {
        if (!strs.length) return '';

        let prefix = strs[0];

        for (let i = 1; i < strs.length; i++) {
            let j = 0;
            while (j < prefix.length && j < strs[i].length && prefix[j] === strs[i][j]) {
            j++;
            }
            if (j === 0) return '';
            prefix = prefix.substring(0, j);
        }

        return prefix;
        }
        Time Complexity: The brute force solution has a time complexity of O(S), where S is the sum of all characters in the array of strings. The optimized solution also has a time complexity of O(S), but it may perform better in some cases due to early termination.

        Space Complexity: Both solutions have a space complexity of O(1).

Problem 8: Count and Say
        Problem Statement: The count-and-say sequence is a series of strings where each string is formed by "saying" the counts of consecutive digits. Starting with the base case "1," the following string is derived by reading the previous string: "1" is read as "one 1," so the next string is "11." Given an integer n, generate the nth string in the count-and-say sequence.

        Brute Force Solution:
        function countAndSay(n) {
        if (n === 1) return "1";
        
        let prev = countAndSay(n - 1);
        let result = "";
        
        let count = 1;
        for (let i = 0; i < prev.length; i++) {
            if (prev[i] === prev[i + 1]) {
            count++;
            } else {
            result += count + prev[i];
            count = 1;
            }
        }
        
        return result;
        }
        Optimized Solution:
        function countAndSay(n) {
        if (n === 1) return "1";
        
        let result = "1";
        
        for (let i = 2; i <= n; i++) {
            let current = "";
            let count = 1;
            
            for (let j = 0; j < result.length; j++) {
            if (result[j] === result[j + 1]) {
                count++;
            } else {
                current += count + result[j];
                count = 1;
            }
            }
            
            result = current;
        }
        
        return result;
        }
        Time Complexity: Both solutions have a time complexity of O(2^n), where n is the input integer.

        Space Complexity: Both solutions have a space complexity of O(2^n) due to the recursive calls in the brute force solution and the iterative approach in the optimized solution.

Problem 9: ZigZag Conversion
        Problem Statement: The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows. For example, if the input string is "PAYPALISHIRING" and the number of rows is 3, the zigzag pattern would be:

        css
        Copy code
        P   A   H   N
        A P L S I I G
        Y   I   R
        And the output would be the concatenation of rows: "PAHNAPLSIIGYIR".

        Brute Force Solution:
        function convert(s, numRows) {
        if (numRows === 1) return s;
        6
        const rows = Array.from({ length: numRows }, () => "");
        let direction = 1;
        let currentRow = 0;
        
        for (let char of s) {
            rows[currentRow] += char;
            
            if (currentRow === 0) {
            direction = 1;
            } else if (currentRow === numRows - 1) {
            direction = -1;
            }
            
            currentRow += direction;
        }
        
        return rows.join("");
        }
        Optimized Solution:
        function convert(s, numRows) {
        if (numRows === 1) return s;
        
        const rows = Array.from({ length: Math.min(numRows, s.length) }, () => "");
        let currentRow = 0;
        let goingDown = false;
        
        for (let char of s) {
            rows[currentRow] += char;
            
            if (currentRow === 0 || currentRow === numRows - 1) {
            goingDown = !goingDown;
            }
            
            currentRow += goingDown ? 1 : -1;
        }
        
        return rows.join("");
        }
        Time Complexity: Both solutions have a time complexity of O(n), where n is the length of the input string.

        Space Complexity: Both solutions have a space complexity of O(n), where n is the length of the input string.

Problem 10: Group Anagrams
        Problem Statement: Given an array of strings, group anagrams together.

        Brute Force Solution:
        function groupAnagrams(strs) {
        const anagrams = {};

        for (let str of strs) {
            const sortedStr = str.split('').sort().join('');
            if (!anagrams[sortedStr]) {
            anagrams[sortedStr] = [str];
            } else {
            anagrams[sortedStr].push(str);
            }
        }

        return Object.values(anagrams);
        }
        Optimized Solution:
        function groupAnagrams(strs) {
        const anagrams = {};

        for (let str of strs) {
            const charCount = Array(26).fill(0);

            for (let char of str) {
            charCount[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;
            }

            const key = charCount.join(',');

            if (!anagrams[key]) {
            anagrams[key] = [str];
            } else {
            anagrams[key].push(str);
            }
        }

        return Object.values(anagrams);
        }
        Time Complexity: The brute force solution has a time complexity of O(n * m * log(m)), where n is the number of strings, and m is the maximum length of a string. 
        The optimized solution has a time complexity of O(n * m), where n is the number of strings, and m is the maximum length of a string.

        Space Complexity: Both solutions have a space complexity of O(n * m), where n is the number of strings, and m is the maximum length of a string.

Problem 11: Valid Parentheses
        Problem Statement: Given a string containing just the characters '(', ')', '{', '}', '[', and ']', determine if the input string is valid.

        Solution:
        function isValid(s) {
        const stack = [];
        const mapping = {')': '(', '}': '{', ']': '['};

        for (let char of s) {
            if (char in mapping) {
            const topElement = stack.length === 0 ? '#' : stack.pop();
            if (mapping[char] !== topElement) {
                return false;
            }
            } else {
            stack.push(char);
            }
        }

        return stack.length === 0;
        }
        Time Complexity: The time complexity of this solution is O(n), where n is the length of the input string.

        Space Complexity: The space complexity is O(n), where n is the length of the input string.

Problem 12: Implement strStr() (Substring Search)
        Problem Statement: Return the index of the first occurrence of the needle in the haystack, or -1 if the needle is not part of the haystack.

        Brute Force Solution:
        function strStr(haystack, needle) {
        if (needle === '') return 0;

        for (let i = 0; i <= haystack.length - needle.length; i++) {
            let j;
            for (j = 0; j < needle.length; j++) {
            if (haystack[i + j] !== needle[j]) {
                break;
            }
            }
            if (j === needle.length) {
            return i;
            }
        }

        return -1;
        }
        Optimized Solution (KMP Algorithm):
        function strStr(haystack, needle) {
        if (needle === '') return 0;

        const prefixTable = buildPrefixTable(needle);
        let i = 0;
        let j = 0;

        while (i < haystack.length) {
            if (haystack[i] === needle[j]) {
            i++;
            j++;
            if (j === needle.length) {
                return i - j;
            }
            } else if (j > 0) {
            j = prefixTable[j - 1];
            } else {
            i++;
            }
        }

        return -1;
        }

        function buildPrefixTable(needle) {
        const table = [0];
        let prefixLength = 0;

        for (let i = 1; i < needle.length; i++) {
            if (needle[i] === needle[prefixLength]) {
            prefixLength++;
            } else if (prefixLength > 0) {
            prefixLength = table[prefixLength - 1];
            i--; // Continue checking the current character in the next iteration
            } else {
            table[i] = 0;
            }
        }

        return table;
        }
        Time Complexity: The brute force solution has a time complexity of O(n * m), where n is the length of the haystack and m is the length of the needle. 
        The KMP algorithm provides an optimized solution with a time complexity of O(n + m).

        Space Complexity: The brute force solution has a space complexity of O(1). The KMP algorithm has a space complexity of O(m), where m is the length of the needle.

Problem 13: String Compression
        Problem Statement: Given an array of characters, compress it in-place and return the new length. 
        The solution should be in constant space.

        Solution:
        function compress(chars) {
        let writeIndex = 0;
        let readIndex = 0;

        while (readIndex < chars.length) {
            let char = chars[readIndex];
            let count = 0;

            while (readIndex < chars.length && chars[readIndex] === char) {
            readIndex++;
            count++;
            }

            chars[writeIndex++] = char;

            if (count > 1) {
            for (let digit of count.toString()) {
                chars[writeIndex++] = digit;
            }
            }
        }

        return writeIndex;
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input array.

        Space Complexity: The space complexity is O(1).

Problem 14: Longest Palindromic Substring
        Problem Statement: Given a string s, return the longest palindromic substring in s.

        Brute Force Solution:
        function longestPalindrome(s) {
        let longest = '';

        for (let i = 0; i < s.length; i++) {
            for (let j = i + 1; j <= s.length; j++) {
            const substring = s.slice(i, j);
            if (isPalindrome(substring) && substring.length > longest.length) {
                longest = substring;
            }
            }
        }

        return longest;
        }

        function isPalindrome(str) {
        return str === str.split('').reverse().join('');
        }
        Optimized Solution:
        function longestPalindrome(s) {
        if (s.length <= 1) return s;

        let start = 0;
        let maxLength = 1;

        function expandAroundCenter(left, right) {
            while (left >= 0 && right < s.length && s[left] === s[right]) {
            const currentLength = right - left + 1;
            if (currentLength > maxLength) {
                maxLength = currentLength;
                start = left;
            }
            left--;
            right++;
            }
        }

        for (let i = 0; i < s.length; i++) {
            expandAroundCenter(i, i); // Odd length palindrome
            expandAroundCenter(i, i + 1); // Even length palindrome
        }

        return s.slice(start, start + maxLength);
        }
        Time Complexity: The brute force solution has a time complexity of O(n^3), where n is the length of the input string. 
        The optimized solution has a time complexity of O(n^2), where n is the length of the input string.

        Space Complexity: Both solutions have a space complexity of O(1).

Problem 15: Reverse Words in a String
        Problem Statement: Given an input string s, reverse the order of the words.

        Solution:
        function reverseWords(s) {
        const words = s.trim().split(/\s+/);
        return words.reverse().join(' ');
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input string.

        Space Complexity: The space complexity is O(n), where n is the length of the input string.

Problem 16: Minimum Window Substring
        Problem Statement: Given a string s and a string t, find the minimum window in s that contains all the characters of t in complexity O(n).

        Solution:
        function minWindow(s, t) {
        const charCount = {};
        let requiredChars = 0;

        for (let char of t) {
            charCount[char] = (charCount[char] || 0) + 1;
            requiredChars++;
        }

        let left = 0;
        let right = 0;
        let minWindow = Infinity;
        let minWindowStart = 0;

        while (right < s.length) {
            if (charCount[s[right]] > 0) {
            requiredChars--;
            }
            charCount[s[right]]--;

            while (requiredChars === 0) {
            if (right - left + 1 < minWindow) {
                minWindow = right - left + 1;
                minWindowStart = left;
            }

            charCount[s[left]]++;
            if (charCount[s[left]] > 0) {
                requiredChars++;
            }

            left++;
            }

            right++;
        }

        return minWindow === Infinity ? '' : s.slice(minWindowStart, minWindowStart + minWindow);
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input string s.

        Space Complexity: The space complexity is O(k), where k is the number of unique characters in string t.

Problem 17: Add Binary
        Problem Statement: Given two binary strings a and b, return their sum as a binary string.

        Solution:
        function addBinary(a, b) {
        let result = '';
        let carry = 0;
        let i = a.length - 1;
        let j = b.length - 1;

        while (i >= 0 || j >= 0 || carry > 0) {
            const sum = (i >= 0 ? parseInt(a[i]) : 0) + (j >= 0 ? parseInt(b[j]) : 0) + carry;
            result = (sum % 2) + result;
            carry = Math.floor(sum / 2);
            i--;
            j--;
        }

        return result;
        }
        Time Complexity: The time complexity is O(max(n, m)), where n and m are the lengths of the input binary strings a and b.

        Space Complexity: The space complexity is O(max(n, m)), where n and m are the lengths of the input binary strings a and b.

Problem 18: Valid Palindrome II
        Problem Statement: Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome.

        Solution:
        function validPalindrome(s) {
        function isPalindromeRange(left, right) {
            while (left < right) {
            if (s[left] !== s[right]) {
                return false;
            }
            left++;
            right--;
            }
            return true;
        }

        let left = 0;
        let right = s.length - 1;

        while (left < right) {
            if (s[left] !== s[right]) {
            return isPalindromeRange(left + 1, right) || isPalindromeRange(left, right - 1);
            }
            left++;
            right--;
        }

        return true;
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input string s.

        Space Complexity: The space complexity is O(1).

Problem 19: Longest Substring with At Most K Distinct Characters
        Problem Statement: Given a string s and an integer k, return the length of the longest substring with at most k distinct characters.

        Solution:
        function lengthOfLongestSubstringKDistinct(s, k) {
        const charCount = {};
        let distinctCount = 0;
        let left = 0;
        let maxLength = 0;

        for (let right = 0; right < s.length; right++) {
            if (!(s[right] in charCount) || charCount[s[right]] === 0) {
            distinctCount++;
            }
            charCount[s[right]] = (charCount[s[right]] || 0) + 1;

            while (distinctCount > k) {
            charCount[s[left]]--;
            if (charCount[s[left]] === 0) {
                distinctCount--;
            }
            left++;
            }

            maxLength = Math.max(maxLength, right - left + 1);
        }

        return maxLength;
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input string s.

        Space Complexity: The space complexity is O(k), where k is the number of distinct characters.

Problem 20: Compare Version Numbers
        Problem Statement: Compare two version numbers version1 and version2. If version1 > version2, return 1; if version1 < version2, return -1; otherwise, return 0.

        Solution:
        function compareVersion(version1, version2) {
        const v1 = version1.split('.');
        const v2 = version2.split('.');
        const length = Math.max(v1.length, v2.length);

        for (let i = 0; i < length; i++) {
            const num1 = i < v1.length ? parseInt(v1[i]) : 0;
            const num2 = i < v2.length ? parseInt(v2[i]) : 0;

            if (num1 > num2) {
            return 1;
            } else if (num1 < num2) {
            return -1;
            }
        }

        return 0;
        }
        Time Complexity: The time complexity is O(max(n, m)), where n and m are the lengths of the input version strings version1 and version2.

        Space Complexity: The space complexity is O(max(n, m)), where n and m are the lengths of the input version strings version1 and version2.

Problem 21: Palindromic Substrings
        Problem Statement: Given a string, your task is to count how many palindromic substrings in this string.

        Solution:
        function countSubstrings(s) {
        let count = 0;

        function expandAroundCenter(left, right) {
            while (left >= 0 && right < s.length && s[left] === s[right]) {
            count++;
            left--;
            right++;
            }
        }

        for (let i = 0; i < s.length; i++) {
            expandAroundCenter(i, i); // Odd length palindromes
            expandAroundCenter(i, i + 1); // Even length palindromes
        }

        return count;
        }
        Time Complexity: The time complexity is O(n^2), where n is the length of the input string s.

        Space Complexity: The space complexity is O(1).

Problem 22: Valid Number
        Problem Statement: Implement a function to check if a given string is a valid number (integer or floating-point).

        Solution:
        function isNumber(s) {
        const regex = /^\s*[+-]?(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?\s*$/;
        return regex.test(s);
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input string s.

        Space Complexity: The space complexity is O(1).

Problem 23: Simplify Path
        Problem Statement: Given a string path, simplify it to the canonical path.

        Solution:
        function simplifyPath(path) {
        const segments = path.split('/');
        const stack = [];

        for (let segment of segments) {
            if (segment === '..') {
            stack.pop();
            } else if (segment && segment !== '.') {
            stack.push(segment);
            }
        }

        return '/' + stack.join('/');
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input string path.

        Space Complexity: The space complexity is O(n), where n is the length of the input string path.

Problem 24: Text Justification
        Problem Statement: Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.

        Solution:
        function fullJustify(words, maxWidth) {
        const result = [];
        let line = [];
        let lineLength = 0;

        for (let word of words) {
            if (lineLength + line.length + word.length > maxWidth) {
            for (let i = 0; i < maxWidth - lineLength; i++) {
                line[i % (line.length - 1 || 1)] += ' ';
            }
            result.push(line.join(''));
            line = [];
            lineLength = 0;
            }

            line.push(word);
            lineLength += word.length;
        }

        result.push(line.join(' ').padEnd(maxWidth, ' '));
        return result;
        }
        Time Complexity: The time complexity is O(n), where n is the total number of characters in the input words array.

        Space Complexity: The space complexity is O(1).

Problem 25: Reverse Words in a String III
        Problem Statement: Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.

        Solution:
        function reverseWords(s) {
        const words = s.split(' ');
        for (let i = 0; i < words.length; i++) {
            words[i] = words[i].split('').reverse().join('');
        }
        return words.join(' ');
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input string s.

        Space Complexity: The space complexity is O(n), where n is the length of the input string s.

Problem 26: Decode Ways
        Problem Statement: A message containing letters from A-Z can be encoded into numbers using the following mapping:

        rust
        Copy code
        'A' -> "1"
        'B' -> "2"
        ...
        'Z' -> "26"
        Given a string s containing only digits, determine the total number of ways to decode it.

        Solution:
        function numDecodings(s) {
        if (s.length === 0 || s[0] === '0') return 0;

        let prev = 1;
        let current = 1;

        for (let i = 1; i < s.length; i++) {
            const temp = current;
            if (s[i] === '0') {
            if (s[i - 1] === '1' || s[i - 1] === '2') {
                current = prev;
            } else {
                return 0;
            }
            } else if (s[i - 1] === '1' || (s[i - 1] === '2' && s[i] >= '1' && s[i] <= '6')) {
            current += prev;
            }
            prev = temp;
        }

        return current;
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input string s.

        Space Complexity: The space complexity is O(1).

Problem 27: Remove K Digits
        Problem Statement: Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.

        Solution:
        function removeKdigits(num, k) {
        const stack = [];

        for (let digit of num) {
            while (k > 0 && stack.length > 0 && digit < stack[stack.length - 1]) {
            stack.pop();
            k--;
            }
            stack.push(digit);
        }

        while (k > 0) {
            stack.pop();
            k--;
        }

        let result = stack.join('').replace(/^0+/, '');
        return result === '' ? '0' : result;
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input string num.

        Space Complexity: The space complexity is O(n), where n is the length of the input string num.

Problem 28: Count Binary Substrings
        Problem Statement: Give a binary string s, count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.

        Solution:
        function countBinarySubstrings(s) {
        let prevCount = 0;
        let currentCount = 1;
        let totalCount = 0;

        for (let i = 1; i < s.length; i++) {
            if (s[i] === s[i - 1]) {
            currentCount++;
            } else {
            prevCount = currentCount;
            currentCount = 1;
            }

            if (prevCount >= currentCount) {
            totalCount++;
            }
        }

        return totalCount;
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input string s.

        Space Complexity: The space complexity is O(1).

Problem 29: Longest Subsequence Repeated k Times
        Problem Statement: Given a string s, find the length of the longest substring that can be repeated exactly k times. If no such substring exists, return 0.

        Solution:
        function longestSubsequenceRepeatedK(s, k) {
        for (let len = s.length / k; len >= 1; len--) {
            for (let i = 0; i <= s.length - len * k; i++) {
            const subsequence = s.slice(i, i + len);
            let count = 1;
            let j = i + len;

            while (count < k) {
                const nextSubsequence = s.slice(j, j + len);
                if (subsequence !== nextSubsequence) {
                break;
                }
                count++;
                j += len;
            }

            if (count === k) {
                return len * k;
            }
            }
        }

        return 0;
        }
        Time Complexity: The time complexity is O(n^2), where n is the length of the input string s.

        Space Complexity: The space complexity is O(n).

Problem 30: Valid Parenthesis String
        Problem Statement: Given a string containing only three types of characters: '(', ')' and '', write a function to check whether this string is valid. The '' character can represent either a '(' or ')' character.

        Solution:
        function checkValidString(s) {
        let low = 0;
        let high = 0;

        for (let char of s) {
            low += char === '(' ? 1 : -1;
            high += char !== ')' ? 1 : -1;

            if (high < 0) {
            break;
            }

            low = Math.max(low, 0);
        }

        return low === 0;
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input string s.

        Space Complexity: The space complexity is O(1).

Problem 31: Reorganize String
        Problem Statement: Given a string s, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same. If possible, output any valid result.

        Solution:
        function reorganizeString(s) {
        const charCount = {};
        let maxChar = '';
        let maxCount = 0;

        for (let char of s) {
            charCount[char] = (charCount[char] || 0) + 1;
            if (charCount[char] > maxCount) {
            maxCount = charCount[char];
            maxChar = char;
            }
        }

        if (maxCount > Math.floor((s.length + 1) / 2)) {
            return '';
        }

        let result = Array(s.length).fill('');
        let index = 0;

        while (charCount[maxChar] > 0) {
            result[index] = maxChar;
            index += 2;
            charCount[maxChar]--;
        }

        for (let char in charCount) {
            while (charCount[char] > 0) {
            if (index >= s.length) {
                index = 1;
            }
            result[index] = char;
            index += 2;
            charCount[char]--;
            }
        }

        return result.join('');
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input string s.

        Space Complexity: The space complexity is O(1).

Problem 32: Distinct Subsequences
        Problem Statement: Given two strings s and t, return the number of distinct subsequences of s which equals t.

        Solution:
        function numDistinct(s, t) {
        const dp = Array.from({ length: t.length + 1 }, () => Array(s.length + 1).fill(0));

        for (let j = 0; j <= s.length; j++) {
            dp[0][j] = 1;
        }

        for (let i = 1; i <= t.length; i++) {
            for (let j = 1; j <= s.length; j++) {
            dp[i][j] = dp[i][j - 1] + (t[i - 1] === s[j - 1] ? dp[i - 1][j - 1] : 0);
            }
        }

        return dp[t.length][s.length];
        }
        Time Complexity: The time complexity is O(m * n), where m is the length of string t and n is the length of string s.

        Space Complexity: The space complexity is O(m * n), where m is the length of string t and n is the length of string s.

Problem 33: Minimum Remove to Make Valid Parentheses
        Problem Statement: Given a string s of '(' , ')' and lowercase English characters. Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions) so that the resulting parentheses string is valid and return any valid string.

        Solution:
        function minRemoveToMakeValid(s) {
        const stack = [];
        const toRemove = new Set();

        for (let i = 0; i < s.length; i++) {
            if (s[i] === '(') {
            stack.push(i);
            } else if (s[i] === ')') {
            if (stack.length === 0) {
                toRemove.add(i);
            } else {
                stack.pop();
            }
            }
        }

        while (stack.length > 0) {
            toRemove.add(stack.pop());
        }

        let result = '';
        for (let i = 0; i < s.length; i++) {
            if (!toRemove.has(i)) {
            result += s[i];
            }
        }

        return result;
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input string s.

        Space Complexity: The space complexity is O(n).

Problem 34: Find the Difference
        Problem Statement: Given two strings s and t which consist of lowercase letters, find the letter that is missing in t.

        Solution:
        function findTheDifference(s, t) {
        let result = 0;

        for (let char of s) {
            result ^= char.charCodeAt(0);
        }

        for (let char of t) {
            result ^= char.charCodeAt(0);
        }

        return String.fromCharCode(result);
        }
        Time Complexity: The time complexity is O(n), where n is the length of the longer string between s and t.

        Space Complexity: The space complexity is O(1).

Problem 35: Remove Duplicate Letters
        Problem Statement: Given a string s, remove duplicate letters so that every letter appears once and only once. Return the result in lexicographical order.

        Solution:
        function removeDuplicateLetters(s) {
        const charCount = {};
        const inStack = {};
        const stack = [];

        for (let char of s) {
            charCount[char] = (charCount[char] || 0) + 1;
        }

        for (let char of s) {
            charCount[char]--;

            if (inStack[char]) {
            continue;
            }

            while (
            stack.length > 0 &&
            char < stack[stack.length - 1] &&
            charCount[stack[stack.length - 1]] > 0
            ) {
            inStack[stack.pop()] = false;
            }

            stack.push(char);
            inStack[char] = true;
        }

        return stack.join('');
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input string s.

        Space Complexity: The space complexity is O(1) since the maximum number of unique characters is constant (26 lowercase letters).

Problem 36: Regular Expression Matching
        Problem Statement: Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*'.

        sql
        Copy code
        '.' Matches any single character.
        '*' Matches zero or more of the preceding element.
        Solution:
        function isMatch(s, p) {
        const dp = Array.from({ length: s.length + 1 }, () => Array(p.length + 1).fill(false));
        dp[0][0] = true;

        for (let j = 1; j <= p.length; j++) {
            if (p[j - 1] === '*') {
            dp[0][j] = dp[0][j - 2];
            }
        }

        for (let i = 1; i <= s.length; i++) {
            for (let j = 1; j <= p.length; j++) {
            if (p[j - 1] === s[i - 1] || p[j - 1] === '.') {
                dp[i][j] = dp[i - 1][j - 1];
            } else if (p[j - 1] === '*') {
                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] === p[j - 2] || p[j - 2] === '.'));
            }
            }
        }

        return dp[s.length][p.length];
        }
        Time Complexity: The time complexity is O(m * n), where m is the length of the input string s and n is the length of the pattern p.

        Space Complexity: The space complexity is O(m * n), where m is the length of the input string s and n is the length of the pattern p.

Problem 37: Palindrome Pairs
        Problem Statement: Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e., words[i] + words[j], is a palindrome.

        Solution:
        function isPalindrome(str) {
        let left = 0;
        let right = str.length - 1;

        while (left < right) {
            if (str[left] !== str[right]) {
            return false;
            }
            left++;
            right--;
        }

        return true;
        }

        function palindromePairs(words) {
        const result = [];

        for (let i = 0; i < words.length; i++) {
            for (let j = 0; j < words.length; j++) {
            if (i !== j) {
                const concatenated = words[i] + words[j];
                if (isPalindrome(concatenated)) {
                result.push([i, j]);
                }
            }
            }
        }

        return result;
        }
        Time Complexity: The time complexity is O(n^2 * m), where n is the number of words and m is the maximum length of a word.

        Space Complexity: The space complexity is O(1).

Problem 38: Ransom Note
        Problem Statement: Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines; otherwise, it will return false.

        Solution:
        function canConstruct(ransomNote, magazine) {
        const charCount = {};

        for (let char of magazine) {
            charCount[char] = (charCount[char] || 0) + 1;
        }

        for (let char of ransomNote) {
            if (!charCount[char]) {
            return false;
            }
            charCount[char]--;
        }

        return true;
        }
        Time Complexity: The time complexity is O(m + n), where m is the length of the ransom note and n is the length of the magazine.

        Space Complexity: The space complexity is O(m), where m is the length of the ransom note.

Problem 39: Camelcase Matching
        Problem Statement: Given an array of strings queries and a string pattern, return a boolean array answer where answer[i] is true if queries[i] matches the pattern.

        A query word queries[i] matches pattern if you can insert lowercase English letters into pattern to get queries[i].

        Solution:
        function camelMatch(queries, pattern) {
        function isMatch(query, pattern) {
            let i = 0;

            for (let char of query) {
            if (i < pattern.length && char === pattern[i]) {
                i++;
            } else if (char === char.toUpperCase()) {
                return false;
            }
            }

            return i === pattern.length;
        }

        return queries.map(query => isMatch(query, pattern));
        }
        Time Complexity: The time complexity is O(m * n), where m is the number of queries, and n is the maximum length of a query.

        Space Complexity: The space complexity is O(m), where m is the number of queries.

Problem 40: Compare Strings by Frequency of the Smallest Character
        Problem Statement: Let f(s) be the frequency of the smallest character in a non-empty string s. Given an array of strings words and an array of queries queries, for each query query[i] = [x, y], find the number of words in words such that f(words[j]) is greater than f(query[i][0]) but less than f(query[i][1]).

        Solution:
        function numSmallerByFrequency(words, queries) {
        function countSmallestCharFrequency(word) {
            const charCount = Array(26).fill(0);
            let smallestChar = 'z';

            for (let char of word) {
            charCount[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;
            smallestChar = Math.min(smallestChar, char);
            }

            return charCount[smallestChar.charCodeAt(0) - 'a'.charCodeAt(0)];
        }

        const wordFrequencies = words.map(word => countSmallestCharFrequency(word));
        wordFrequencies.sort((a, b) => a - b);

        return queries.map(query => {
            const count = countSmallestCharFrequency(query[0]);
            let result = 0;

            for (let frequency of wordFrequencies) {
            if (frequency > count) {
                result++;
            } else {
                break;
            }
            }

            return result;
        });
        }
        Time Complexity: The time complexity is O(n * m + m * log(m)), where n is the number of words, and m is the maximum length of a word.

        Space Complexity: The space complexity is O(n).

Problem 41: Add Strings
        Problem Statement: Given two non-negative integers, num1 and num2 represented as strings, return the sum of num1 and num2.

        Solution:
        function addStrings(num1, num2) {
        let carry = 0;
        let result = '';

        for (let i = num1.length - 1, j = num2.length - 1; i >= 0 || j >= 0 || carry > 0; i--, j--) {
            const digit1 = i >= 0 ? parseInt(num1[i]) : 0;
            const digit2 = j >= 0 ? parseInt(num2[j]) : 0;

            const sum = digit1 + digit2 + carry;
            result = (sum % 10) + result;
            carry = Math.floor(sum / 10);
        }

        return result;
        }
        Time Complexity: The time complexity is O(max(n, m)), where n and m are the lengths of the input strings num1 and num2.

        Space Complexity: The space complexity is O(max(n, m)), where n and m are the lengths of the input strings num1 and num2.

Problem 42: Minimum Deletions to Make Character Frequencies Unique
        Problem Statement: Given a string s consisting of lowercase letters, you need to delete the minimum number of characters from s so that every letter in s appears a unique number of times. We only care about the occurrences of letters that appear at least once in the resulting string.

        Return the minimum number of deletions needed.

        Solution:
        function minDeletions(s) {
        const charCount = Array(26).fill(0);
        const freqSet = new Set();
        let deletions = 0;

        for (let char of s) {
            charCount[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;
        }

        for (let count of charCount) {
            while (count > 0 && freqSet.has(count)) {
            count--;
            deletions++;
            }
            if (count > 0) {
            freqSet.add(count);
            }
        }

        return deletions;
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input string s.

        Space Complexity: The space complexity is O(1) since the maximum number of unique frequencies is constant (26 lowercase letters).

Problem 43: ZigZag Conversion
        Problem Statement: The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this:

        css
        Copy code
        P   A   H   N
        A P L S I I G
        Y   I   R
        And then read line by line: "PAHNAPLSIIGYIR".

        Write the code that will take a string and make this conversion given a number of rows.

        Solution:
        function convert(s, numRows) {
        if (numRows === 1) return s;

        const rows = Array(numRows).fill('');
        let index = 0;
        let direction = 1;

        for (let char of s) {
            rows[index] += char;
            if (index === 0) {
            direction = 1;
            } else if (index === numRows - 1) {
            direction = -1;
            }
            index += direction;
        }

        return rows.join('');
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input string s.

        Space Complexity: The space complexity is O(n), where n is the length of the input string s.

Problem 44: Maximum Score Words Formed by Letters
        Problem Statement: Given a list of words, list of 26 non-negative integers letters representing the number of occurrences of each letter, and an integer k. You need to maximize the score of any valid set of words you can form with the given letters.

        A valid set is formed by selecting some words from the list, such that you can form any word from the list by concatenating some of these words together and still the number of occurrences of each letter is less than or equal to k.

        The score is the sum of the values of letters in the set.

        Solution:
        function maxScoreWords(words, letters, score) {
        function getWordScore(word) {
            let wordScore = 0;
            for (let char of word) {
            wordScore += score[char.charCodeAt(0) - 'a'.charCodeAt(0)];
            }
            return wordScore;
        }

        function countLetters(word) {
            const charCount = Array(26).fill(0);
            for (let char of word) {
            charCount[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;
            }
            return charCount;
        }

        function canForm(wordCount, letters) {
            for (let i = 0; i < 26; i++) {
            if (wordCount[i] > letters[i]) {
                return false;
            }
            }
            return true;
        }

        function dfs(index, currentCount) {
            if (index === words.length) {
            return 0;
            }

            const withoutWord = dfs(index + 1, currentCount);

            const wordCount = countLetters(words[index]);
            if (canForm(wordCount, currentCount)) {
            for (let i = 0; i < 26; i++) {
                currentCount[i] -= wordCount[i];
            }
            const withWord = getWordScore(words[index]) + dfs(index + 1, currentCount);
            for (let i = 0; i < 26; i++) {
                currentCount[i] += wordCount[i];
            }
            return Math.max(withWord, withoutWord);
            }

            return withoutWord;
        }

        return dfs(0, letters);
        }
        Time Complexity: The time complexity is O(2^n), where n is the number of words.

        Space Complexity: The space complexity is O(n), where n is the number of words.

Problem 45: Minimum Length of String After Deleting Similar Ends
        Problem Statement: Given a string s, return the minimum length of the string after deleting the similar ends.

        You are given a string s consisting of lowercase English letters. A string is called similar to another string if it can be obtained by concatenating some (possibly none or all) of the characters of another string. For example, "abc" is similar to "abac" but not to "acbac".

        Solution:
        function minimumLength(s) {
        let left = 0;
        let right = s.length - 1;

        while (left < right && s[left] === s[right]) {
            const currentChar = s[left];
            while (left <= right && s[left] === currentChar) {
            left++;
            }
            while (left <= right && s[right] === currentChar) {
            right--;
            }
        }

        return right - left + 1;
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input string s.

        Space Complexity: The space complexity is O(1).

Problem 46: Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree
        Problem Statement: Given a binary tree where each node has a value 0 or 1, and a target value arr of length n, return true if there exists a leaf node in the binary tree such that, when traversing the tree from the root to the leaf, the values form the target value arr.

        Solution:
        class TreeNode {
        constructor(val) {
            this.val = val;
            this.left = this.right = null;
        }
        }

        function isValidSequence(root, arr) {
        function dfs(node, index) {
            if (!node || index === arr.length || node.val !== arr[index]) {
            return false;
            }

            if (!node.left && !node.right && index === arr.length - 1) {
            return true;
            }

            return dfs(node.left, index + 1) || dfs(node.right, index + 1);
        }

        return dfs(root, 0);
        }
        Time Complexity: The time complexity is O(n), where n is the length of the target array arr.

        Space Complexity: The space complexity is O(h), where h is the height of the binary tree.

Problem 47: Add Bold Tag in String
        Problem Statement: Given a string s and a list of strings dict, you need to add a closed pair of bold tag <b> and </b> to wrap the substrings in s that exist in dict. If two such substrings overlap, you need to wrap them together by only one pair of closed bold tag. Also, if two substrings wrapped by bold tags are consecutive, you need to combine them.

        Solution:
        function addBoldTag(s, dict) {
        const isBold = Array(s.length).fill(false);

        for (let word of dict) {
            let start = 0;
            while (start < s.length) {
            const index = s.indexOf(word, start);
            if (index === -1) {
                break;
            }
            for (let i = index; i < index + word.length; i++) {
                isBold[i] = true;
            }
            start = index + 1;
            }
        }

        let result = '';
        for (let i = 0; i < s.length; i++) {
            if (isBold[i] && (i === 0 || !isBold[i - 1])) {
            result += '<b>';
            }
            result += s[i];
            if (isBold[i] && (i === s.length - 1 || !isBold[i + 1])) {
            result += '</b>';
            }
        }

        return result;
        }
        Time Complexity: The time complexity is O(m * n), where m is the length of the input string s, and n is the total length of words in the dictionary dict.

        Space Complexity: The space complexity is O(m), where m is the length of the input string s.

Problem 48: Multiply Strings
        Problem Statement: Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2.

        Solution:
        function multiply(num1, num2) {
        const m = num1.length;
        const n = num2.length;
        const result = Array(m + n).fill(0);

        for (let i = m - 1; i >= 0; i--) {
            for (let j = n - 1; j >= 0; j--) {
            const product = parseInt(num1[i]) * parseInt(num2[j]);
            const sum = result[i + j + 1] + product;
            result[i + j + 1] = sum % 10;
            result[i + j] += Math.floor(sum / 10);
            }
        }

        return result.join('').replace(/^0+/, '') || '0';
        }
        Time Complexity: The time complexity is O(m * n), where m and n are the lengths of the input strings num1 and num2.

        Space Complexity: The space complexity is O(m + n), where m and n are the lengths of the input strings num1 and num2.

Problem 49: Minimum ASCII Delete Sum for Two Strings
        Problem Statement: Given two strings s1 and s2, return the lowest ASCII sum of deleted characters to make two strings equal.

        Solution:
        function minimumDeleteSum(s1, s2) {
        const m = s1.length;
        const n = s2.length;
        const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));

        for (let i = m - 1; i >= 0; i--) {
            dp[i][n] = dp[i + 1][n] + s1.charCodeAt(i);
        }

        for (let j = n - 1; j >= 0; j--) {
            dp[m][j] = dp[m][j + 1] + s2.charCodeAt(j);
        }

        for (let i = m - 1; i >= 0; i--) {
            for (let j = n - 1; j >= 0; j--) {
            if (s1[i] === s2[j]) {
                dp[i][j] = dp[i + 1][j + 1];
            } else {
                dp[i][j] = Math.min(
                s1.charCodeAt(i) + dp[i + 1][j],
                s2.charCodeAt(j) + dp[i][j + 1]
                );
            }
            }
        }

        return dp[0][0];
        }
        Time Complexity: The time complexity is O(m * n), where m and n are the lengths of the input strings s1 and s2.

        Space Complexity: The space complexity is O(m * n), where m and n are the lengths of the input strings s1 and s2.

Problem 50: Valid Palindrome II
        Problem Statement: Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome.

        Solution:
        function validPalindrome(s) {
        function isPalindromeRange(left, right) {
            while (left < right) {
            if (s[left] !== s[right]) {
                return false;
            }
            left++;
            right--;
            }
            return true;
        }

        let left = 0;
        let right = s.length - 1;

        while (left < right) {
            if (s[left] !== s[right]) {
            return (
                isPalindromeRange(left + 1, right) || isPalindromeRange(left, right - 1)
            );
            }
            left++;
            right--;
        }

        return true;
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input string s.

        Space Complexity: The space complexity is O(1).

Problem 51: Find All Anagrams in a String
        Problem Statement: Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.

        Solution:
        function findAnagrams(s, p) {
        const result = [];
        const pCount = Array(26).fill(0);
        const windowCount = Array(26).fill(0);
        const aCharCode = 'a'.charCodeAt(0);

        for (let char of p) {
            pCount[char.charCodeAt(0) - aCharCode]++;
        }

        for (let i = 0; i < s.length; i++) {
            windowCount[s[i].charCodeAt(0) - aCharCode]++;

            if (i >= p.length - 1) {
            if (isEqualCounts(pCount, windowCount)) {
                result.push(i - p.length + 1);
            }

            windowCount[s[i - p.length + 1].charCodeAt(0) - aCharCode]--;
            }
        }

        return result;
        }

        function isEqualCounts(arr1, arr2) {
        for (let i = 0; i < arr1.length; i++) {
            if (arr1[i] !== arr2[i]) {
            return false;
            }
        }
        return true;
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input string s.

        Space Complexity: The space complexity is O(1) since the size of the count arrays is constant.

Problem 52: Minimum Swaps to Make Strings Equal
        Problem Statement: You are given two strings s1 and s2 of equal length consisting of letters "x" and "y" only. Your task is to make these two strings equal to each other. You can swap any two characters that belong to different strings, which means: swap s1[i] and s2[j].

        Return the minimum number of swaps required to make s1 and s2 equal. If it is not possible to make the two strings equal, return -1.

        Solution:
        function minimumSwap(s1, s2) {
        let xy = 0; // count of 'x' in s1 and 'y' in s2
        let yx = 0; // count of 'y' in s1 and 'x' in s2

        for (let i = 0; i < s1.length; i++) {
            if (s1[i] === 'x' && s2[i] === 'y') {
            xy++;
            } else if (s1[i] === 'y' && s2[i] === 'x') {
            yx++;
            }
        }

        if ((xy + yx) % 2 !== 0) {
            return -1;
        }

        // If both counts are odd or even, the swaps can be performed to make strings equal
        // If one count is odd and the other is even, it requires two swaps to make strings equal
        return Math.ceil(xy / 2) + Math.ceil(yx / 2);
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input strings s1 and s2.

        Space Complexity: The space complexity is O(1).

Problem 53: Custom Sort String
        Problem Statement: S and T are strings composed of lowercase letters. In S, no letter occurs more than once.

        S was sorted in some custom order previously. We want to permute the characters of T so that they match the order that S was sorted. More specifically, if x occurs before y in S, then x should occur before y in the output.

        Return any permutation of T (as a string) that satisfies this property.

        Solution:
        function customSortString(S, T) {
        const charCount = Array(26).fill(0);

        for (let char of T) {
            charCount[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;
        }

        let result = '';

        for (let char of S) {
            while (charCount[char.charCodeAt(0) - 'a'.charCodeAt(0)] > 0) {
            result += char;
            charCount[char.charCodeAt(0) - 'a'.charCodeAt(0)]--;
            }
        }

        for (let i = 0; i < 26; i++) {
            while (charCount[i] > 0) {
            result += String.fromCharCode('a'.charCodeAt(0) + i);
            charCount[i]--;
            }
        }

        return result;
        }
        Time Complexity: The time complexity is O(n + m), where n is the length of the string T and m is the length of the string S.

        Space Complexity: The space complexity is O(1) since the size of the count array is constant.

Problem 54: Backspace String Compare
        Problem Statement: Given two strings S and T, return true if they are equal when both are typed into empty text editors. # means a backspace character.

        Note that after backspacing an empty text, the text will continue to be empty.

        Solution:
        function backspaceCompare(S, T) {
        function processString(s) {
            const stack = [];

            for (let char of s) {
            if (char === '#') {
                stack.pop();
            } else {
                stack.push(char);
            }
            }

            return stack.join('');
        }

        return processString(S) === processString(T);
        }
        Time Complexity: The time complexity is O(m + n), where m and n are the lengths of the input strings S and T.

        Space Complexity: The space complexity is O(m + n), where m and n are the lengths of the input strings S and T.

Problem 55: Group Anagrams
        Problem Statement: Given an array of strings strs, group the anagrams together. You can return the answer in any order.

        An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

        Solution:
        function groupAnagrams(strs) {
        const anagramsMap = new Map();

        for (let str of strs) {
            const sortedStr = str.split('').sort().join('');
            
            if (!anagramsMap.has(sortedStr)) {
            anagramsMap.set(sortedStr, []);
            }
            
            anagramsMap.get(sortedStr).push(str);
        }

        return Array.from(anagramsMap.values());
        }
        Time Complexity: The time complexity is O(n * k * log(k)), where n is the number of strings and k is the maximum length of a string.

        Space Complexity: The space complexity is O(n * k), where n is the number of strings and k is the maximum length of a string.

Problem 56: Reverse Words in a String III
        Problem Statement: Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.

        Solution:
        function reverseWords(s) {
        const words = s.split(' ');

        for (let i = 0; i < words.length; i++) {
            words[i] = words[i].split('').reverse().join('');
        }

        return words.join(' ');
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input string s.

        Space Complexity: The space complexity is O(n), where n is the length of the input string s.

Problem 57: Count Binary Substrings
        Problem Statement: Give a binary string s, count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.

        Solution:
        function countBinarySubstrings(s) {
        let count = 0;
        let prevCount = 0;
        let currentCount = 1;

        for (let i = 1; i < s.length; i++) {
            if (s[i] === s[i - 1]) {
            currentCount++;
            } else {
            prevCount = currentCount;
            currentCount = 1;
            }

            if (prevCount >= currentCount) {
            count++;
            }
        }

        return count;
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input string s.

        Space Complexity: The space complexity is O(1).

Problem 58: Repeated Substring Pattern
        Problem Statement: Given a non-empty string s, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume that the given string s consists of lowercase English letters only.

        Solution:
        function repeatedSubstringPattern(s) {
        const n = s.length;

        for (let len = 1; len <= n / 2; len++) {
            if (n % len === 0) {
            const pattern = s.substring(0, len);
            let isValid = true;

            for (let i = len; i < n; i += len) {
                if (s.substring(i, i + len) !== pattern) {
                isValid = false;
                break;
                }
            }

            if (isValid) {
                return true;
            }
            }
        }

        return false;
        }
        Time Complexity: The time complexity is O(n^2), where n is the length of the input string s.

        Space Complexity: The space complexity is O(1).

Problem 59: Palindromic Substrings
        Problem Statement: Given a string s, return the number of palindromic substrings in it. A string is a palindrome when it reads the same backward as forward.

        Solution:
        function countSubstrings(s) {
        let count = 0;

        for (let center = 0; center < 2 * s.length - 1; center++) {
            let left = Math.floor(center / 2);
            let right = left + (center % 2);

            while (left >= 0 && right < s.length && s[left] === s[right]) {
            count++;
            left--;
            right++;
            }
        }

        return count;
        }
        Time Complexity: The time complexity is O(n^2), where n is the length of the input string s.

        Space Complexity: The space complexity is O(1).

Problem 60: Longest Substring Without Repeating Characters
        Problem Statement: Given a string s, find the length of the longest substring without repeating characters.

        Solution:
        function lengthOfLongestSubstring(s) {
        const charIndexMap = new Map();
        let maxLength = 0;
        let start = 0;

        for (let end = 0; end < s.length; end++) {
            if (charIndexMap.has(s[end]) && charIndexMap.get(s[end]) >= start) {
            start = charIndexMap.get(s[end]) + 1;
            }

            maxLength = Math.max(maxLength, end - start + 1);
            charIndexMap.set(s[end], end);
        }

        return maxLength;
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input string s.

        Space Complexity: The space complexity is O(min(n, m)), where n is the length of the input string s, and m is the size of the character set.

Problem 61: String Compression
        Problem Statement: Given an array of characters chars, compress it using the following algorithm:

        Begin with an empty string result.
        For each group of consecutive repeating characters in chars:

        Append the character to result.
        If the group length is greater than 1, append the count of characters.
        Return the modified array.
        Solution:
        function compress(chars) {
        let writeIndex = 0;
        let readIndex = 0;

        while (readIndex < chars.length) {
            let currentChar = chars[readIndex];
            let count = 0;

            while (readIndex < chars.length && chars[readIndex] === currentChar) {
            readIndex++;
            count++;
            }

            chars[writeIndex++] = currentChar;

            if (count > 1) {
            for (let digit of count.toString()) {
                chars[writeIndex++] = digit;
            }
            }
        }

        return writeIndex;
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input array chars.

        Space Complexity: The space complexity is O(1).

Problem 62: Word Ladder
        Problem Statement: Given two words beginWord and endWord, and a dictionary word list, return the length of the shortest transformation sequence from beginWord to endWord. If no such transformation sequence exists, return 0.

        Each transformation must change exactly one letter of the current word and may not use the same word from the dictionary more than once.

        Solution:
        function ladderLength(beginWord, endWord, wordList) {
        const wordSet = new Set(wordList);
        if (!wordSet.has(endWord)) {
            return 0;
        }

        const queue = [];
        queue.push(beginWord);
        let level = 1;

        while (queue.length > 0) {
            const size = queue.length;

            for (let i = 0; i < size; i++) {
            const currentWord = queue.shift();

            for (let j = 0; j < currentWord.length; j++) {
                for (let k = 97; k <= 122; k++) {
                const newWord =
                    currentWord.substring(0, j) + String.fromCharCode(k) + currentWord.substring(j + 1);

                if (newWord === endWord) {
                    return level + 1;
                }

                if (wordSet.has(newWord)) {
                    queue.push(newWord);
                    wordSet.delete(newWord);
                }
                }
            }
            }

            level++;
        }

        return 0;
        }
        Time Complexity: The time complexity is O(M * N), where M is the length of the words, and N is the total number of words in the wordList.

        Space Complexity: The space complexity is O(N).

Problem 63: Valid Parenthesis String
        Problem Statement: Given a string containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. We define the validity of a string by these rules:

        Any left parenthesis '(' must have a corresponding right parenthesis ')'.
        Any right parenthesis ')' must have a corresponding left parenthesis '('.
        Left parenthesis '(' must go before the corresponding right parenthesis ')'.
        '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string.
        An empty string is also valid.

        Solution:
        function checkValidString(s) {
        let low = 0;
        let high = 0;

        for (let char of s) {
            low += char === '(' ? 1 : -1;
            high += char !== ')' ? 1 : -1;

            if (high < 0) {
            break;
            }

            low = Math.max(low, 0);
        }

        return low === 0;
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input string s.

        Space Complexity: The space complexity is O(1).

Problem 64: Find the Duplicate Subtrees
        Problem Statement: Given the root of a binary tree, return all duplicate subtrees.

        For each kind of duplicate subtrees, you only need to return the root node of any one of them.

        Two trees are duplicate if they have the same structure with the same node values.

        Solution:
        class TreeNode {
        constructor(val) {
            this.val = val;
            this.left = this.right = null;
        }
        }

        function findDuplicateSubtrees(root) {
        const treeCountMap = new Map();
        const result = [];

        function serialize(node) {
            if (!node) {
            return '#';
            }

            const serialized = node.val + ',' + serialize(node.left) + ',' + serialize(node.right);

            if (treeCountMap.has(serialized)) {
            treeCountMap.set(serialized, treeCountMap.get(serialized) + 1);
            if (treeCountMap.get(serialized) === 2) {
                result.push(node);
            }
            } else {
            treeCountMap.set(serialized, 1);
            }

            return serialized;
        }

        serialize(root);

        return result;
        }
        Time Complexity: The time complexity is O(n), where n is the number of nodes in the binary tree.

        Space Complexity: The space complexity is O(n), where n is the number of nodes in the binary tree.

Problem 65: Regular Expression Matching
        Problem Statement: Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*'.

        '.' Matches any single character.
        '*' Matches zero or more of the preceding element.
        The matching should cover the entire input string (not partial).

        Solution:
        function isMatch(s, p) {
        const dp = Array.from({ length: s.length + 1 }, () => Array(p.length + 1).fill(false));
        dp[0][0] = true;

        for (let j = 1; j <= p.length; j++) {
            if (p[j - 1] === '*') {
            dp[0][j] = dp[0][j - 2];
            }
        }

        for (let i = 1; i <= s.length; i++) {
            for (let j = 1; j <= p.length; j++) {
            if (p[j - 1] === s[i - 1] || p[j - 1] === '.') {
                dp[i][j] = dp[i - 1][j - 1];
            } else if (p[j - 1] === '*') {
                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] === p[j - 2] || p[j - 2] === '.'));
            }
            }
        }

        return dp[s.length][p.length];
        }
        Time Complexity: The time complexity is O(m * n), where m is the length of the input string s, and n is the length of the pattern p.

        Space Complexity: The space complexity is O(m * n), where m is the length of the input string s, and n is the length of the pattern p.

Problem 66: Edit Distance
        Problem Statement: Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.

        You have the following three operations permitted on a word:

        Insert a character
        Delete a character
        Replace a character
        Solution:
        function minDistance(word1, word2) {
        const m = word1.length;
        const n = word2.length;
        const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));

        for (let i = 0; i <= m; i++) {
            for (let j = 0; j <= n; j++) {
            if (i === 0) {
                dp[i][j] = j;
            } else if (j === 0) {
                dp[i][j] = i;
            } else if (word1[i - 1] === word2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = 1 + Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);
            }
            }
        }

        return dp[m][n];
        }
        Time Complexity: The time complexity is O(m * n), where m is the length of word1, and n is the length of word2.

        Space Complexity: The space complexity is O(m * n), where m is the length of word1, and n is the length of word2.

Problem 67: Valid Number
        Problem Statement: Validate if a given string can be interpreted as a decimal number.

        A valid decimal number must satisfy the following rules:

        Number can contain leading whitespaces or consist of whitespaces only.
        Number can contain leading and trailing zeros (but not zero in the middle).
        Number can be positive or negative.
        Number can be an integer or have a decimal point.
        Number can have an optional exponent part, preceded by an 'e' or 'E', which may be positive or negative.
        Solution:
        function isNumber(s) {
        const regex = /^\s*([-+]?(\d+(\.\d*)?|\.\d+)([eE][-+]?\d+)?)\s*$/;
        return regex.test(s);
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input string s.

        Space Complexity: The space complexity is O(1).

Problem 68: Minimum Window Substring
        Problem Statement: Given a string s and a string t, find the minimum window in s that contains all the characters of t in complexity O(n).

        Solution:
        function minWindow(s, t) {
        const charCount = new Map();

        for (let char of t) {
            charCount.set(char, charCount.get(char) + 1 || 1);
        }

        let left = 0;
        let right = 0;
        let minWindow = '';
        let minLen = Infinity;
        let count = t.length;

        while (right < s.length) {
            if (charCount.has(s[right])) {
            charCount.set(s[right], charCount.get(s[right]) - 1);
            if (charCount.get(s[right]) >= 0) {
                count--;
            }
            }

            while (count === 0) {
            if (right - left + 1 < minLen) {
                minLen = right - left + 1;
                minWindow = s.substring(left, right + 1);
            }

            if (charCount.has(s[left])) {
                charCount.set(s[left], charCount.get(s[left]) + 1);
                if (charCount.get(s[left]) > 0) {
                count++;
                }
            }

            left++;
            }

            right++;
        }

        return minWindow;
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input string s.

        Space Complexity: The space complexity is O(k), where k is the size of the character set.

Problem 69: Evaluate Reverse Polish Notation
        Problem Statement: Evaluate the value of an arithmetic expression in Reverse Polish Notation.

        Valid operators are +, -, *, and /. Each operand may be an integer or another expression.

        Solution:
        function evalRPN(tokens) {
        const stack = [];

        for (let token of tokens) {
            if (isNaN(token)) {
            const operand2 = stack.pop();
            const operand1 = stack.pop();

            switch (token) {
                case '+':
                stack.push(operand1 + operand2);
                break;
                case '-':
                stack.push(operand1 - operand2);
                break;
                case '*':
                stack.push(operand1 * operand2);
                break;
                case '/':
                stack.push(parseInt(operand1 / operand2));
                break;
            }
            } else {
            stack.push(parseInt(token));
            }
        }

        return stack.pop();
        }
        Time Complexity: The time complexity is O(n), where n is the number of elements in the input array tokens.

        Space Complexity: The space complexity is O(n), where n is the number of elements in the input array tokens.

Problem 70: Alien Dictionary
        Problem Statement: There is a new alien language that uses the English alphabet. However, the order among letters are unknown to you. You are given a list of strings words from the alien language's dictionary, where the strings in words are sorted lexicographically by the rules of this new language. Return a string of the unique letters in the new alien language sorted in lexicographically increasing order.

        If there is no solution, return an empty string. If there are multiple solutions, return any valid order.

        Solution:
        function alienOrder(words) {
        const graph = new Map();
        const inDegree = new Map();

        for (let word of words) {
            for (let char of word) {
            graph.set(char, []);
            inDegree.set(char, 0);
            }
        }

        for (let i = 0; i < words.length - 1; i++) {
            const currentWord = words[i];
            const nextWord = words[i + 1];
            const minLength = Math.min(currentWord.length, nextWord.length);

            for (let j = 0; j < minLength; j++) {
            const currentChar = currentWord[j];
            const nextChar = nextWord[j];

            if (currentChar !== nextChar) {
                graph.get(currentChar).push(nextChar);
                inDegree.set(nextChar, inDegree.get(nextChar) + 1);
                break;
            }
            }
        }

        const queue = [];
        for (let [char, degree] of inDegree.entries()) {
            if (degree === 0) {
            queue.push(char);
            }
        }

        const result = [];

        while (queue.length > 0) {
            const currentChar = queue.shift();
            result.push(currentChar);

            for (let nextChar of graph.get(currentChar)) {
            inDegree.set(nextChar, inDegree.get(nextChar) - 1);
            if (inDegree.get(nextChar) === 0) {
                queue.push(nextChar);
            }
            }
        }

        return result.length === inDegree.size ? result.join('') : '';
        }
        Time Complexity: The time complexity is O(C), where C is the total number of characters in the input words.

        Space Complexity: The space complexity is O(C).

Problem 71: Palindrome Pairs
        Problem Statement: Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e., words[i] + words[j] is a palindrome.

        Solution:
        function isPalindrome(word, start, end) {
        while (start < end) {
            if (word[start] !== word[end]) {
            return false;
            }
            start++;
            end--;
        }
        return true;
        }

        function palindromePairs(words) {
        const result = [];

        for (let i = 0; i < words.length; i++) {
            for (let j = 0; j < words.length; j++) {
            if (i !== j) {
                const concatenated = words[i] + words[j];
                if (isPalindrome(concatenated, 0, concatenated.length - 1)) {
                result.push([i, j]);
                }
            }
            }
        }

        return result;
        }
        Time Complexity: The time complexity is O(N^2 * K), where N is the number of words, and K is the average length of the words.

        Space Complexity: The space complexity is O(1).

Problem 72: Longest Common Prefix
        Problem Statement: Write a function to find the longest common prefix string amongst an array of strings.

        If there is no common prefix, return an empty string ''.

        Solution:
        function longestCommonPrefix(strs) {
        if (strs.length === 0) {
            return '';
        }

        let prefix = strs[0];

        for (let i = 1; i < strs.length; i++) {
            let j = 0;

            while (j < prefix.length && j < strs[i].length && prefix[j] === strs[i][j]) {
            j++;
            }

            prefix = prefix.substring(0, j);

            if (prefix === '') {
            break;
            }
        }

        return prefix;
        }
        Time Complexity: The time complexity is O(S), where S is the total number of characters in all the strings.

        Space Complexity: The space complexity is O(1).

Problem 73: Partition Labels
        Problem Statement: A string S of lowercase English letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and then return a list of integers representing the size of these parts.

        Solution:
        function partitionLabels(S) {
        const lastOccurrence = new Map();

        for (let i = 0; i < S.length; i++) {
            lastOccurrence.set(S[i], i);
        }

        const result = [];
        let start = 0;
        let end = 0;

        for (let i = 0; i < S.length; i++) {
            end = Math.max(end, lastOccurrence.get(S[i]));

            if (i === end) {
            result.push(end - start + 1);
            start = end + 1;
            }
        }

        return result;
        }
        Time Complexity: The time complexity is O(N), where N is the length of the input string S.

        Space Complexity: The space complexity is O(1).

Problem 74: Valid Palindrome
        Problem Statement: Given a string s, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

        Solution:
        function isPalindrome(s) {
        s = s.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();
        let left = 0;
        let right = s.length - 1;

        while (left < right) {
            if (s[left] !== s[right]) {
            return false;
            }
            left++;
            right--;
        }

        return true;
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input string s.

        Space Complexity: The space complexity is O(1).

Problem 75: String to Integer (atoi)
        Problem Statement: Implement the myAtoi function, which converts a string to an integer.

        The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.

        The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.

        If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.

        If no valid conversion could be performed, a zero value is returned.

        Solution:
        function myAtoi(str) {
        const INT_MAX = 2 ** 31 - 1;
        const INT_MIN = -(2 ** 31);

        let i = 0;
        let sign = 1;
        let result = 0;

        while (i < str.length && str[i] === ' ') {
            i++;
        }

        if (str[i] === '+' || str[i] === '-') {
            sign = str[i] === '+' ? 1 : -1;
            i++;
        }

        while (i < str.length && isDigit(str[i])) {
            const digit = parseInt(str[i]);

            if (result > (INT_MAX - digit) / 10) {
            return sign === 1 ? INT_MAX : INT_MIN;
            }

            result = result * 10 + digit;
            i++;
        }

        return sign * result;
        }

        function isDigit(char) {
        return char >= '0' && char <= '9';
        }
        Time Complexity: The time complexity is O(n), where n is the length of the input string str.

        Space Complexity: The space complexity is O(1).


